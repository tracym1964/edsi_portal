from datetime import datetime, timedelta
import time
import random
import threading
import uuid
import ctypes


class IDGenerator:
    node_id = 2L
    user_id = 0L
    boot_time = datetime.utcnow()
    ryko_epoch = datetime(2015, 1, 1)
    boot_seconds_since_epoch = long((boot_time - ryko_epoch).total_seconds())
    i15 = 0
    i18 = 0
    i40 = 0
    lock = threading.Lock()
    #last_uuid = uuid.UUID(bytes='\x00'*16)
    @classmethod
    def generate_short_uuid(cls):
        # This routine was found to generate duplicate ids by a single process with multiple worker tasks

        # short_uuid algorithm inspired by MySQL's uuid_short function.
        # 16 bits for node id, which allows for 64 k unique nodes.
        # 30 bits composed from the boot time calculated as the number of seconds that have elapsed since 1/1/2015. (wraps in 34 years)
        # 18 bits forming a sequential number. Max range of 256 k, but we spill over into timestamp bits if necessary
        #
        # With this algorithm we could see ID collisions if two devices with the same node_id are booted within 1 second
        # of each other. Ryko should only have ~1000 devices in the field at any one time. Devices get the same node_id
        # when their user_device._id's differ by a multiple of 64 k. If this collision risk isn't acceptable, we could
        # take more bits from the sequence and devote them to the other fields (ie store boot time in centiseconds)
        #
        # Another collision possibility is to generate more than 256 k IDs per second, which will wrap the timestamp,
        # and then reboot so that the timebits appear to go back in time. This algorithm simply is not designed to
        # handle that. We would need to steal bits from the node id or timestamp and devote them to the sequence
        # number.

        with cls.lock:
            cls.i18 = (cls.i18 + 1) & 0x3FFFF
            if cls.i18 == 0:
                # handle the edge case where the entire sequence is exhausted by simply bumping the boot seconds.
                cls.boot_seconds_since_epoch += 1

            result = ((cls.node_id & 0xFFFFL) << 48) | ((cls.boot_seconds_since_epoch & 0x3FFFFFFFL) << 18) | cls.i18

            if result & 0x8000000000000000L:
                # if the sign bit is set, then convert the ID to negative python number that will generate the same 8
                # byte bit pattern in the database. We do this because the table is defined as a signed number for
                # compatibility with sqlite (which doesn't support unsigned 8 byte numbers)
                result = -0x10000000000000000 + result

            return result

    @classmethod
    def generate_bigint_uuid(cls, source):
        # short_uuid algorithm - new
        # left-most digit for source id.
        # digits 2-14 for # of seconds since 1970 (python's time.time() rounded up 2 decimal places
        # digits 15-19 for random number

        with cls.lock:
            lt = long(time.time() * 100)
            rt = int(random.randrange(0, 99999))
            st = str(source) + str(lt) + str(rt).zfill(5)
            uid = long(st)
            return uid

    @classmethod
    def generate_identity(cls):
        # generate a simple 8 byte identity sequence that is composed of a 3 byte device ID OR'd with a sequential
        # 40 bit number. This format is easy to work with because IDs generated at ryko look like simple integers.
        #  IDs created else where will have some of the higher bits set, which will make them look like huge numbers.
        # The downer is that the i48 needs to be persisted and re-loaded across program instances, so we don't
        # generate the same IDs after a program boot.
        with cls.lock:
            cls.i40 += 1
            return ((cls.node_id & 0xFFFFFFL) << 40) | cls.i40

    @classmethod
    def generate_short_uuid_timestamp_based(cls):
        # short uuid implemented like a full uuid, except using fewer bits and allowing for less frequent generation
        # 13 bits for node id, which allows for 8192 unique nodes.
        # 36 bit timestamp generated by calculating the number of centiseconds that have elapsed since since 1/1/2015. (wraps in 21.8 years)
        # 15 bits forming a sequential number. Time + seq implies that we can generate at most 32 k IDs per 10 ms window
        # which works out to 1 ID every 300 ns
        #
        # With this algorithm we could see ID collisions if two devices with the same node_id generate IDs within 10 ms
        # of each other and happen to be on the same sequence number.

        with cls.lock:
            cls.i15 = (cls.i15 + 1) & 0x7FFF
            now = datetime.utcnow()
            delta = now - cls.ryko_epoch
            centiseconds = long(delta.total_seconds() * 100)


            # return result with timestamp in the MSB
            result = (centiseconds & 0xFFFFFFFFFL) << 28 | cls.i12 << 13 | (cls.node_id & 0x1FFFL)

            if result & 0x8000000000000000L:
                # if the sign bit is set, then convert the ID to negative python number that will generate the same 8
                # byte bit pattern in the database. We do this because the table is defined as a signed number for
                # compatibility with sqlite (which doesn't support unsigned 8 byte numbers)
                result = -0x10000000000000000 + result

            return result


def generate_short_uuid():
    return IDGenerator.generate_short_uuid()

def reorder_uuid_time_bytes(uuid):
    # version 1 uuid's follow this format:
    # Data1 : 4 byte int : low 4 bytes of the timestamp stored in big endian format
    # Data2 : 2 byte int : middle 2 bytes of the timestamp stored in big endian
    # Data3 : 2 byte int : version nibble plus high 12 bits of the timestamp
    # Data4 : 16 bytes   : node ID plus various other bits
    #
    # Sequentially created uuid's are not index friendly because of the layout of the timestamp bits. We can
    # fix that by reorganizing the bytes in the uuid.
    #
    # example: Here is a sequence of uuid's generated within a few seconds of each other by the mysql uuid function
    # 6eec5eb6-9755-11e4-b981-feb7b39d48d6
    # 6eec5f10-9755-11e4-b981-feb7b39d48d6
    # 6eec8ddc-9755-11e4-b981-feb7b39d48d6
    # 6eee30d0-9755-11e4-b981-feb7b39d48d6
    # 6efda038-9755-11e4-b981-feb7b39d48d6
    # 6f9641bf-9755-11e4-b981-feb7b39d48d6
    # 758c3e3e-9755-11e4-b981-feb7b39d48d6
    #
    # Reorganizing the timestamp bits from MSB to LSB creates a better primary key
    # 11e4 9755 6eec5eb6...
    # 11e4 9755 6eec5f10...
    # 11e4 9755 6eec8ddc...
    # 11e4 9755 6eee30d0...
    # 11e4 9755 6efda038...
    # 11e4 9755 6f9641bf...
    # 11e4 9755 758c3e3e...

    return uuid.bytes[6:8] + uuid.bytes[4:6] + uuid.bytes[0:4] + uuid.bytes[8:]


def generate_uuid():
    return uuid.UUID(bytes=generate_uuid_key_bytes())


def generate_uuid_key_bytes():
    return reorder_uuid_time_bytes(uuid.uuid1())
